// Generated by gencpp from file data_parse/Object.msg
// DO NOT EDIT!


#ifndef DATA_PARSE_MESSAGE_OBJECT_H
#define DATA_PARSE_MESSAGE_OBJECT_H


#include <string>
#include <vector>
#include <memory>

#include <ros/types.h>
#include <ros/serialization.h>
#include <ros/builtin_message_traits.h>
#include <ros/message_operations.h>

#include <geometry_msgs/Vector3.h>
#include <geometry_msgs/Vector3.h>
#include <geometry_msgs/Vector3.h>
#include <geometry_msgs/Vector3.h>
#include <geometry_msgs/Vector3.h>
#include <geometry_msgs/Vector3.h>
#include <geometry_msgs/Vector3.h>
#include <geometry_msgs/Vector3.h>
#include <geometry_msgs/Vector3.h>
#include <geometry_msgs/Vector3.h>

namespace data_parse
{
template <class ContainerAllocator>
struct Object_
{
  typedef Object_<ContainerAllocator> Type;

  Object_()
    : id(0)
    , life_cycles(0)
    , classification(0)
    , obstacle_probability(0.0)
    , probability_existence(0.0)
    , center()
    , center_uncertainty()
    , heading_angle(0.0)
    , heading_angle_uncertainty(0.0)
    , length(0.0)
    , width(0.0)
    , height(0.0)
    , relative_velocity()
    , relative_velocity_uncertainty()
    , relative_accelerate()
    , relative_accelerate_uncertainty()
    , absolute_velocity()
    , absolute_velocity_uncertainty()
    , absolute_accelerate()
    , absolute_accelerate_uncertainty()
    , ObjNearestPtX(0.0)
    , ObjNearestPtY(0.0)
    , ObjNearestPtZ(0.0)
    , chks(0)
    , cntr(0)
    , dynamic_property(0)
    , snr(0)
    , rcs(0.0)
    , classification_confidence(0.0)
    , update_bit(0)
    , update_flag(0)
    , valid_flag(0)
    , speed(0.0)
    , accelerate(0.0)
    , vision_id(0)
    , CllsnMtgtnByBrkgPrimQly(0)
    , CllsnMtgtnByBrkgSecQly(0)
    , EmgyLaneKeepAidPosnQly(0)
    , CllsnWarnFwdQly(0)
    , fusion_source(0)
    , time_stamp(0.0)
    , lane_offset_right(0.0)
    , lane_offset_right_dev(0.0)
    , indicator_state(0)  {
    }
  Object_(const ContainerAllocator& _alloc)
    : id(0)
    , life_cycles(0)
    , classification(0)
    , obstacle_probability(0.0)
    , probability_existence(0.0)
    , center(_alloc)
    , center_uncertainty(_alloc)
    , heading_angle(0.0)
    , heading_angle_uncertainty(0.0)
    , length(0.0)
    , width(0.0)
    , height(0.0)
    , relative_velocity(_alloc)
    , relative_velocity_uncertainty(_alloc)
    , relative_accelerate(_alloc)
    , relative_accelerate_uncertainty(_alloc)
    , absolute_velocity(_alloc)
    , absolute_velocity_uncertainty(_alloc)
    , absolute_accelerate(_alloc)
    , absolute_accelerate_uncertainty(_alloc)
    , ObjNearestPtX(0.0)
    , ObjNearestPtY(0.0)
    , ObjNearestPtZ(0.0)
    , chks(0)
    , cntr(0)
    , dynamic_property(0)
    , snr(0)
    , rcs(0.0)
    , classification_confidence(0.0)
    , update_bit(0)
    , update_flag(0)
    , valid_flag(0)
    , speed(0.0)
    , accelerate(0.0)
    , vision_id(0)
    , CllsnMtgtnByBrkgPrimQly(0)
    , CllsnMtgtnByBrkgSecQly(0)
    , EmgyLaneKeepAidPosnQly(0)
    , CllsnWarnFwdQly(0)
    , fusion_source(0)
    , time_stamp(0.0)
    , lane_offset_right(0.0)
    , lane_offset_right_dev(0.0)
    , indicator_state(0)  {
  (void)_alloc;
    }



   typedef uint16_t _id_type;
  _id_type id;

   typedef int16_t _life_cycles_type;
  _life_cycles_type life_cycles;

   typedef uint8_t _classification_type;
  _classification_type classification;

   typedef double _obstacle_probability_type;
  _obstacle_probability_type obstacle_probability;

   typedef double _probability_existence_type;
  _probability_existence_type probability_existence;

   typedef  ::geometry_msgs::Vector3_<ContainerAllocator>  _center_type;
  _center_type center;

   typedef  ::geometry_msgs::Vector3_<ContainerAllocator>  _center_uncertainty_type;
  _center_uncertainty_type center_uncertainty;

   typedef double _heading_angle_type;
  _heading_angle_type heading_angle;

   typedef double _heading_angle_uncertainty_type;
  _heading_angle_uncertainty_type heading_angle_uncertainty;

   typedef float _length_type;
  _length_type length;

   typedef float _width_type;
  _width_type width;

   typedef float _height_type;
  _height_type height;

   typedef  ::geometry_msgs::Vector3_<ContainerAllocator>  _relative_velocity_type;
  _relative_velocity_type relative_velocity;

   typedef  ::geometry_msgs::Vector3_<ContainerAllocator>  _relative_velocity_uncertainty_type;
  _relative_velocity_uncertainty_type relative_velocity_uncertainty;

   typedef  ::geometry_msgs::Vector3_<ContainerAllocator>  _relative_accelerate_type;
  _relative_accelerate_type relative_accelerate;

   typedef  ::geometry_msgs::Vector3_<ContainerAllocator>  _relative_accelerate_uncertainty_type;
  _relative_accelerate_uncertainty_type relative_accelerate_uncertainty;

   typedef  ::geometry_msgs::Vector3_<ContainerAllocator>  _absolute_velocity_type;
  _absolute_velocity_type absolute_velocity;

   typedef  ::geometry_msgs::Vector3_<ContainerAllocator>  _absolute_velocity_uncertainty_type;
  _absolute_velocity_uncertainty_type absolute_velocity_uncertainty;

   typedef  ::geometry_msgs::Vector3_<ContainerAllocator>  _absolute_accelerate_type;
  _absolute_accelerate_type absolute_accelerate;

   typedef  ::geometry_msgs::Vector3_<ContainerAllocator>  _absolute_accelerate_uncertainty_type;
  _absolute_accelerate_uncertainty_type absolute_accelerate_uncertainty;

   typedef double _ObjNearestPtX_type;
  _ObjNearestPtX_type ObjNearestPtX;

   typedef double _ObjNearestPtY_type;
  _ObjNearestPtY_type ObjNearestPtY;

   typedef double _ObjNearestPtZ_type;
  _ObjNearestPtZ_type ObjNearestPtZ;

   typedef uint8_t _chks_type;
  _chks_type chks;

   typedef uint8_t _cntr_type;
  _cntr_type cntr;

   typedef uint8_t _dynamic_property_type;
  _dynamic_property_type dynamic_property;

   typedef uint8_t _snr_type;
  _snr_type snr;

   typedef double _rcs_type;
  _rcs_type rcs;

   typedef double _classification_confidence_type;
  _classification_confidence_type classification_confidence;

   typedef uint8_t _update_bit_type;
  _update_bit_type update_bit;

   typedef uint8_t _update_flag_type;
  _update_flag_type update_flag;

   typedef uint8_t _valid_flag_type;
  _valid_flag_type valid_flag;

   typedef double _speed_type;
  _speed_type speed;

   typedef double _accelerate_type;
  _accelerate_type accelerate;

   typedef uint8_t _vision_id_type;
  _vision_id_type vision_id;

   typedef uint8_t _CllsnMtgtnByBrkgPrimQly_type;
  _CllsnMtgtnByBrkgPrimQly_type CllsnMtgtnByBrkgPrimQly;

   typedef uint8_t _CllsnMtgtnByBrkgSecQly_type;
  _CllsnMtgtnByBrkgSecQly_type CllsnMtgtnByBrkgSecQly;

   typedef uint8_t _EmgyLaneKeepAidPosnQly_type;
  _EmgyLaneKeepAidPosnQly_type EmgyLaneKeepAidPosnQly;

   typedef uint8_t _CllsnWarnFwdQly_type;
  _CllsnWarnFwdQly_type CllsnWarnFwdQly;

   typedef uint8_t _fusion_source_type;
  _fusion_source_type fusion_source;

   typedef double _time_stamp_type;
  _time_stamp_type time_stamp;

   typedef double _lane_offset_right_type;
  _lane_offset_right_type lane_offset_right;

   typedef double _lane_offset_right_dev_type;
  _lane_offset_right_dev_type lane_offset_right_dev;

   typedef uint8_t _indicator_state_type;
  _indicator_state_type indicator_state;



// reducing the odds to have name collisions with Windows.h 
#if defined(_WIN32) && defined(UNCLASSIFIED)
  #undef UNCLASSIFIED
#endif
#if defined(_WIN32) && defined(UNKNOWN_SMALL)
  #undef UNKNOWN_SMALL
#endif
#if defined(_WIN32) && defined(UNKNOWN_BIG)
  #undef UNKNOWN_BIG
#endif
#if defined(_WIN32) && defined(PEDESTRIAN)
  #undef PEDESTRIAN
#endif
#if defined(_WIN32) && defined(BIKE)
  #undef BIKE
#endif
#if defined(_WIN32) && defined(CAR)
  #undef CAR
#endif
#if defined(_WIN32) && defined(TRUCK)
  #undef TRUCK
#endif
#if defined(_WIN32) && defined(CLASS_UNKNOWN)
  #undef CLASS_UNKNOWN
#endif
#if defined(_WIN32) && defined(CLASS_CAR)
  #undef CLASS_CAR
#endif
#if defined(_WIN32) && defined(CLASS_TRUCK)
  #undef CLASS_TRUCK
#endif
#if defined(_WIN32) && defined(CLASS_MOTORCYCLE)
  #undef CLASS_MOTORCYCLE
#endif
#if defined(_WIN32) && defined(CLASS_CYCLIST)
  #undef CLASS_CYCLIST
#endif
#if defined(_WIN32) && defined(CLASS_PEDESTRIAN)
  #undef CLASS_PEDESTRIAN
#endif
#if defined(_WIN32) && defined(CLASS_ROAD_BARRIER)
  #undef CLASS_ROAD_BARRIER
#endif
#if defined(_WIN32) && defined(CLASS_MAX_NUM)
  #undef CLASS_MAX_NUM
#endif
#if defined(_WIN32) && defined(INDICATOR_UNDEFINED)
  #undef INDICATOR_UNDEFINED
#endif
#if defined(_WIN32) && defined(INDICATOR_OFF)
  #undef INDICATOR_OFF
#endif
#if defined(_WIN32) && defined(INDICATOR_RIGHT)
  #undef INDICATOR_RIGHT
#endif
#if defined(_WIN32) && defined(INDICATOR_LEFT)
  #undef INDICATOR_LEFT
#endif
#if defined(_WIN32) && defined(INDICATOR_BOTH)
  #undef INDICATOR_BOTH
#endif

  enum {
    UNCLASSIFIED = 0u,
    UNKNOWN_SMALL = 1u,
    UNKNOWN_BIG = 2u,
    PEDESTRIAN = 3u,
    BIKE = 4u,
    CAR = 5u,
    TRUCK = 6u,
    CLASS_UNKNOWN = 0u,
    CLASS_CAR = 1u,
    CLASS_TRUCK = 2u,
    CLASS_MOTORCYCLE = 3u,
    CLASS_CYCLIST = 4u,
    CLASS_PEDESTRIAN = 5u,
    CLASS_ROAD_BARRIER = 6u,
    CLASS_MAX_NUM = 7u,
    INDICATOR_UNDEFINED = 0u,
    INDICATOR_OFF = 1u,
    INDICATOR_RIGHT = 2u,
    INDICATOR_LEFT = 3u,
    INDICATOR_BOTH = 4u,
  };


  typedef boost::shared_ptr< ::data_parse::Object_<ContainerAllocator> > Ptr;
  typedef boost::shared_ptr< ::data_parse::Object_<ContainerAllocator> const> ConstPtr;

}; // struct Object_

typedef ::data_parse::Object_<std::allocator<void> > Object;

typedef boost::shared_ptr< ::data_parse::Object > ObjectPtr;
typedef boost::shared_ptr< ::data_parse::Object const> ObjectConstPtr;

// constants requiring out of line definition

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   



template<typename ContainerAllocator>
std::ostream& operator<<(std::ostream& s, const ::data_parse::Object_<ContainerAllocator> & v)
{
ros::message_operations::Printer< ::data_parse::Object_<ContainerAllocator> >::stream(s, "", v);
return s;
}


template<typename ContainerAllocator1, typename ContainerAllocator2>
bool operator==(const ::data_parse::Object_<ContainerAllocator1> & lhs, const ::data_parse::Object_<ContainerAllocator2> & rhs)
{
  return lhs.id == rhs.id &&
    lhs.life_cycles == rhs.life_cycles &&
    lhs.classification == rhs.classification &&
    lhs.obstacle_probability == rhs.obstacle_probability &&
    lhs.probability_existence == rhs.probability_existence &&
    lhs.center == rhs.center &&
    lhs.center_uncertainty == rhs.center_uncertainty &&
    lhs.heading_angle == rhs.heading_angle &&
    lhs.heading_angle_uncertainty == rhs.heading_angle_uncertainty &&
    lhs.length == rhs.length &&
    lhs.width == rhs.width &&
    lhs.height == rhs.height &&
    lhs.relative_velocity == rhs.relative_velocity &&
    lhs.relative_velocity_uncertainty == rhs.relative_velocity_uncertainty &&
    lhs.relative_accelerate == rhs.relative_accelerate &&
    lhs.relative_accelerate_uncertainty == rhs.relative_accelerate_uncertainty &&
    lhs.absolute_velocity == rhs.absolute_velocity &&
    lhs.absolute_velocity_uncertainty == rhs.absolute_velocity_uncertainty &&
    lhs.absolute_accelerate == rhs.absolute_accelerate &&
    lhs.absolute_accelerate_uncertainty == rhs.absolute_accelerate_uncertainty &&
    lhs.ObjNearestPtX == rhs.ObjNearestPtX &&
    lhs.ObjNearestPtY == rhs.ObjNearestPtY &&
    lhs.ObjNearestPtZ == rhs.ObjNearestPtZ &&
    lhs.chks == rhs.chks &&
    lhs.cntr == rhs.cntr &&
    lhs.dynamic_property == rhs.dynamic_property &&
    lhs.snr == rhs.snr &&
    lhs.rcs == rhs.rcs &&
    lhs.classification_confidence == rhs.classification_confidence &&
    lhs.update_bit == rhs.update_bit &&
    lhs.update_flag == rhs.update_flag &&
    lhs.valid_flag == rhs.valid_flag &&
    lhs.speed == rhs.speed &&
    lhs.accelerate == rhs.accelerate &&
    lhs.vision_id == rhs.vision_id &&
    lhs.CllsnMtgtnByBrkgPrimQly == rhs.CllsnMtgtnByBrkgPrimQly &&
    lhs.CllsnMtgtnByBrkgSecQly == rhs.CllsnMtgtnByBrkgSecQly &&
    lhs.EmgyLaneKeepAidPosnQly == rhs.EmgyLaneKeepAidPosnQly &&
    lhs.CllsnWarnFwdQly == rhs.CllsnWarnFwdQly &&
    lhs.fusion_source == rhs.fusion_source &&
    lhs.time_stamp == rhs.time_stamp &&
    lhs.lane_offset_right == rhs.lane_offset_right &&
    lhs.lane_offset_right_dev == rhs.lane_offset_right_dev &&
    lhs.indicator_state == rhs.indicator_state;
}

template<typename ContainerAllocator1, typename ContainerAllocator2>
bool operator!=(const ::data_parse::Object_<ContainerAllocator1> & lhs, const ::data_parse::Object_<ContainerAllocator2> & rhs)
{
  return !(lhs == rhs);
}


} // namespace data_parse

namespace ros
{
namespace message_traits
{





template <class ContainerAllocator>
struct IsMessage< ::data_parse::Object_<ContainerAllocator> >
  : TrueType
  { };

template <class ContainerAllocator>
struct IsMessage< ::data_parse::Object_<ContainerAllocator> const>
  : TrueType
  { };

template <class ContainerAllocator>
struct IsFixedSize< ::data_parse::Object_<ContainerAllocator> >
  : TrueType
  { };

template <class ContainerAllocator>
struct IsFixedSize< ::data_parse::Object_<ContainerAllocator> const>
  : TrueType
  { };

template <class ContainerAllocator>
struct HasHeader< ::data_parse::Object_<ContainerAllocator> >
  : FalseType
  { };

template <class ContainerAllocator>
struct HasHeader< ::data_parse::Object_<ContainerAllocator> const>
  : FalseType
  { };


template<class ContainerAllocator>
struct MD5Sum< ::data_parse::Object_<ContainerAllocator> >
{
  static const char* value()
  {
    return "5ec958fb840aae7c81d40f6c557b44f5";
  }

  static const char* value(const ::data_parse::Object_<ContainerAllocator>&) { return value(); }
  static const uint64_t static_value1 = 0x5ec958fb840aae7cULL;
  static const uint64_t static_value2 = 0x81d40f6c557b44f5ULL;
};

template<class ContainerAllocator>
struct DataType< ::data_parse::Object_<ContainerAllocator> >
{
  static const char* value()
  {
    return "data_parse/Object";
  }

  static const char* value(const ::data_parse::Object_<ContainerAllocator>&) { return value(); }
};

template<class ContainerAllocator>
struct Definition< ::data_parse::Object_<ContainerAllocator> >
{
  static const char* value()
  {
    return "# BO_ 1345 Objects_Header: 3 Vector__XXX\n"
"#  SG_ Sync_Frame_Index : 0|8@1+ (1,0) [0|255] \"counter\" Vector__XXX\n"
"#  SG_ Num_Of_Video_Objs : 8|4@1+ (1,0) [0|12] \"counter\" Vector__XXX\n"
"#  SG_ VD_CIPV_ID : 12|7@1+ (1,0) [0|127] \"counter\" Vector__XXX\n"
"#  SG_ VD_CIPV_Lost : 19|2@1+ (1,0) [0|2] \"ENUM\" Vector__XXX\n"
"#  SG_ OBJ_VD_Allow_Acc : 21|2@1+ (1,0) [0|2] \"ENUM\" Vector__XXX\n"
"#  SG_ Reserved : 23|1@1+ (1,0) [0|0] \"NA\" Vector__XXX\n"
"\n"
"# BO_ 1280 Objects_Signals_A1: 7 Vector__XXX\n"
"#  SG_ Obj_ID_1 : 0|7@1+ (1,0) [0|127] \"counter\" Vector__XXX\n"
"#  SG_ Object_Class_1 : 7|3@1+ (1,0) [0|7] \"ENUM\" Vector__XXX\n"
"#  SG_ OBJ_Width_1 : 10|7@1+ (0.05,0) [0|6.35] \"m\" Vector__XXX\n"
"#  SG_ OBJ_Length_1 : 17|9@1+ (0.05,0) [0|25.5] \"m\" Vector__XXX\n"
"#  SG_ Relative_Long_Velocity_1 : 26|13@1+ (0.05,-120) [-120|130] \"m/s\" Vector__XXX\n"
"#  SG_ OBJ_Lane_Assignment_1 : 39|3@1+ (1,0) [0|5] \"ENUM\" Vector__XXX\n"
"#  SG_ Relative_Lat_Velocity_1 : 42|11@1+ (0.05,-50) [-50|50] \"m/s\" Vector__XXX\n"
"#  SG_ Reserved : 53|3@1+ (1,0) [0|0] \"NA\" Vector__XXX\n"
"\n"
"\n"
"# BO_ 1281 Objects_Signals_B1: 5 Vector__XXX\n"
"#  SG_ Absolute_Long_Acc_1 : 0|9@1+ (0.05,-12.8) [-12.8|12.75] \"m/s2\" Vector__XXX\n"
"#  SG_ Long_Distance_1 : 9|13@1+ (0.05,0) [0|350] \"m\" Vector__XXX\n"
"#  SG_ Lateral_Distance_1 : 22|12@1+ (0.05,-102.4) [-102.4|102.3] \"m\" Vector__XXX\n"
"#  SG_ Reserved : 34|6@1+ (1,0) [0|0] \"NA\" Vector__XXX\n"
"\n"
"\n"
"# BO_ 1282 Objects_Signals_C1: 7 Vector__XXX\n"
"#  SG_ Absolute_Speed_1 : 0|12@1+ (0.05,-100) [-100|100] \"m/s\" Vector__XXX\n"
"#  SG_ OBJ_Motion_Status_1 : 12|3@1+ (1,0) [0|4] \"ENUM \" Vector__XXX\n"
"#  SG_ OBJ_Motion_Category_1 : 15|4@1+ (1,0) [0|12] \"ENUM \" Vector__XXX\n"
"#  SG_ Brake_Light_1 : 19|1@1+ (1,0) [0|1] \"bool\" Vector__XXX\n"
"#  SG_ Turn_Indicator_Right_1 : 20|1@1+ (1,0) [0|1] \"bool\" Vector__XXX\n"
"#  SG_ Turn_Indicator_Left_1 : 21|1@1+ (1,0) [0|1] \"bool\" Vector__XXX\n"
"#  SG_ Light_indicator_validity_1 : 22|1@1+ (1,0) [0|1] \"bool\" Vector__XXX\n"
"#  SG_ OBJ_Angle_Mid_1 : 23|14@1+ (0.0002,-1.571) [-1.571|1.571] \"rad\" Vector__XXX\n"
"#  SG_ OBJ_Angle_Rate_1 : 37|12@1+ (0.002,-2.234) [-2.234|2.2318] \"rad/s\" Vector__XXX\n"
"#  SG_ Reserved : 49|7@1+ (1,0) [0|0] \"NA\" Vector__XXX\n"
"\n"
"uint8 UNCLASSIFIED=0\n"
"uint8 UNKNOWN_SMALL=1\n"
"uint8 UNKNOWN_BIG=2\n"
"uint8 PEDESTRIAN=3\n"
"uint8 BIKE=4\n"
"uint8 CAR=5\n"
"uint8 TRUCK=6\n"
"\n"
"#### ID of this object from tracking. \n"
"#* Obj_ID_1\n"
"uint16 id\n"
"\n"
"#### Number of scans this object has been tracked for.\n"
"int16 life_cycles\n"
"\n"
"#### Most likely class of this object(see top)\n"
"#* Object_Class_1\n"
"uint8 classification\n"
"\n"
"#### The higher this value is the more reliable is the assigned object class\n"
"float64 obstacle_probability\n"
"\n"
"#### The higher this value is the more reliable is the assigned object class\n"
"float64 probability_existence\n"
"\n"
"#### x,y,z in m\n"
"#* Long_Distance_1  Lateral_Distance_1\n"
"geometry_msgs/Vector3 center\n"
"\n"
"#### position untertainty\n"
"geometry_msgs/Vector3 center_uncertainty\n"
"\n"
"#### yaw angle \n"
"#* OBJ_Angle_Rate_1  \n"
"#* OBJ_Angle_Mid_1 \n"
"float64 heading_angle \n"
"\n"
"#### yaw angle uncertainty\n"
"float64 heading_angle_uncertainty\n"
"\n"
"#### Size of the object box in the object, X - length in m\n"
"#* OBJ_Length_1\n"
"float32 length\n"
"\n"
"#### Size of the object box in the object, Y - length in m\n"
"#* OBJ_Width_1\n"
"float32 width\n"
"\n"
"#### Size of the object box in the object, Z - length in m\n"
"float32 height\n"
"\n"
"#### relative_velocity in m/s\n"
"#* Relative_Lat_Velocity_1  Relative_Long_Velocity_1\n"
"geometry_msgs/Vector3 relative_velocity\n"
"\n"
"#### relative_velocity untertainty\n"
"geometry_msgs/Vector3 relative_velocity_uncertainty\n"
"\n"
"#### relative_accelerate in m/s\n"
"geometry_msgs/Vector3 relative_accelerate\n"
"\n"
"#### relative_accelerate untertainty\n"
"geometry_msgs/Vector3 relative_accelerate_uncertainty\n"
"\n"
"#### absolute_velocity in m/s\n"
"#* Absolute_Speed_1\n"
"geometry_msgs/Vector3 absolute_velocity\n"
"\n"
"#### absolute_velocity untertainty\n"
"geometry_msgs/Vector3 absolute_velocity_uncertainty\n"
"\n"
"#### absolute_accelerate in m/s\n"
"#* Absolute_Long_Acc_1\n"
"geometry_msgs/Vector3 absolute_accelerate\n"
"\n"
"#### absolute_accelerate untertainty\n"
"geometry_msgs/Vector3 absolute_accelerate_uncertainty\n"
"\n"
"float64 ObjNearestPtX\n"
"float64 ObjNearestPtY\n"
"float64 ObjNearestPtZ\n"
"\n"
"uint8 chks\n"
"uint8 cntr\n"
"uint8 dynamic_property\n"
"uint8 snr\n"
"float64 rcs\n"
"float64 classification_confidence\n"
"uint8 update_bit\n"
"uint8 update_flag\n"
"uint8 valid_flag\n"
"float64 speed\n"
"float64 accelerate\n"
"uint8 vision_id\n"
"uint8 CllsnMtgtnByBrkgPrimQly\n"
"uint8 CllsnMtgtnByBrkgSecQly\n"
"uint8 EmgyLaneKeepAidPosnQly\n"
"uint8 CllsnWarnFwdQly\n"
"\n"
"uint8 fusion_source\n"
"\n"
"float64 time_stamp\n"
"\n"
"#float64 isp_time_stamp\n"
"\n"
"# enum\n"
"#uint8 Cms_confidence\n"
"#uint8 CmsConfidence1_Invalid = 0\n"
"#uint8 CmsConfidence1_Valid = 1\n"
"#uint8 CmsConfidence1_Reserved = 2\n"
"#uint8 CmsConfidence1_Reserved1 = 3\n"
"\n"
"\n"
"float64 lane_offset_right\n"
"float64 lane_offset_right_dev\n"
"\n"
"\n"
"# ENUM for classification\n"
"uint8 CLASS_UNKNOWN              = 0\n"
"uint8 CLASS_CAR                  = 1\n"
"uint8 CLASS_TRUCK                = 2\n"
"uint8 CLASS_MOTORCYCLE           = 3\n"
"uint8 CLASS_CYCLIST              = 4   # bicyle, E-Scooter, tricyclist\n"
"uint8 CLASS_PEDESTRIAN           = 5\n"
"uint8 CLASS_ROAD_BARRIER         = 6   # traffic cone, parking gate, road barrier\n"
"uint8 CLASS_MAX_NUM              = 7\n"
"\n"
"\n"
"# ENUM for flash light status of the object\n"
"uint8 INDICATOR_UNDEFINED        = 0   # Flash light status is not defined for non-vehicle objects\n"
"uint8 INDICATOR_OFF              = 1   # Flash light is currenhtly not active\n"
"uint8 INDICATOR_RIGHT            = 2   # Right flash light is on and/or blinking\n"
"uint8 INDICATOR_LEFT             = 3   # Left flash light is on and/or blinking\n"
"uint8 INDICATOR_BOTH             = 4   # Flash lights from both side are on and/or blinking\n"
"\n"
"# Flash light status of the object, if applicable (see enum for details)\n"
"#* Turn_Indicator_Left_1 Turn_Indicator_Right_1\n"
"uint8 indicator_state                  # [INDICATOR_*]\n"
"\n"
"================================================================================\n"
"MSG: geometry_msgs/Vector3\n"
"# This represents a vector in free space. \n"
"# It is only meant to represent a direction. Therefore, it does not\n"
"# make sense to apply a translation to it (e.g., when applying a \n"
"# generic rigid transformation to a Vector3, tf2 will only apply the\n"
"# rotation). If you want your data to be translatable too, use the\n"
"# geometry_msgs/Point message instead.\n"
"\n"
"float64 x\n"
"float64 y\n"
"float64 z\n"
;
  }

  static const char* value(const ::data_parse::Object_<ContainerAllocator>&) { return value(); }
};

} // namespace message_traits
} // namespace ros

namespace ros
{
namespace serialization
{

  template<class ContainerAllocator> struct Serializer< ::data_parse::Object_<ContainerAllocator> >
  {
    template<typename Stream, typename T> inline static void allInOne(Stream& stream, T m)
    {
      stream.next(m.id);
      stream.next(m.life_cycles);
      stream.next(m.classification);
      stream.next(m.obstacle_probability);
      stream.next(m.probability_existence);
      stream.next(m.center);
      stream.next(m.center_uncertainty);
      stream.next(m.heading_angle);
      stream.next(m.heading_angle_uncertainty);
      stream.next(m.length);
      stream.next(m.width);
      stream.next(m.height);
      stream.next(m.relative_velocity);
      stream.next(m.relative_velocity_uncertainty);
      stream.next(m.relative_accelerate);
      stream.next(m.relative_accelerate_uncertainty);
      stream.next(m.absolute_velocity);
      stream.next(m.absolute_velocity_uncertainty);
      stream.next(m.absolute_accelerate);
      stream.next(m.absolute_accelerate_uncertainty);
      stream.next(m.ObjNearestPtX);
      stream.next(m.ObjNearestPtY);
      stream.next(m.ObjNearestPtZ);
      stream.next(m.chks);
      stream.next(m.cntr);
      stream.next(m.dynamic_property);
      stream.next(m.snr);
      stream.next(m.rcs);
      stream.next(m.classification_confidence);
      stream.next(m.update_bit);
      stream.next(m.update_flag);
      stream.next(m.valid_flag);
      stream.next(m.speed);
      stream.next(m.accelerate);
      stream.next(m.vision_id);
      stream.next(m.CllsnMtgtnByBrkgPrimQly);
      stream.next(m.CllsnMtgtnByBrkgSecQly);
      stream.next(m.EmgyLaneKeepAidPosnQly);
      stream.next(m.CllsnWarnFwdQly);
      stream.next(m.fusion_source);
      stream.next(m.time_stamp);
      stream.next(m.lane_offset_right);
      stream.next(m.lane_offset_right_dev);
      stream.next(m.indicator_state);
    }

    ROS_DECLARE_ALLINONE_SERIALIZER
  }; // struct Object_

} // namespace serialization
} // namespace ros

namespace ros
{
namespace message_operations
{

template<class ContainerAllocator>
struct Printer< ::data_parse::Object_<ContainerAllocator> >
{
  template<typename Stream> static void stream(Stream& s, const std::string& indent, const ::data_parse::Object_<ContainerAllocator>& v)
  {
    s << indent << "id: ";
    Printer<uint16_t>::stream(s, indent + "  ", v.id);
    s << indent << "life_cycles: ";
    Printer<int16_t>::stream(s, indent + "  ", v.life_cycles);
    s << indent << "classification: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.classification);
    s << indent << "obstacle_probability: ";
    Printer<double>::stream(s, indent + "  ", v.obstacle_probability);
    s << indent << "probability_existence: ";
    Printer<double>::stream(s, indent + "  ", v.probability_existence);
    s << indent << "center: ";
    s << std::endl;
    Printer< ::geometry_msgs::Vector3_<ContainerAllocator> >::stream(s, indent + "  ", v.center);
    s << indent << "center_uncertainty: ";
    s << std::endl;
    Printer< ::geometry_msgs::Vector3_<ContainerAllocator> >::stream(s, indent + "  ", v.center_uncertainty);
    s << indent << "heading_angle: ";
    Printer<double>::stream(s, indent + "  ", v.heading_angle);
    s << indent << "heading_angle_uncertainty: ";
    Printer<double>::stream(s, indent + "  ", v.heading_angle_uncertainty);
    s << indent << "length: ";
    Printer<float>::stream(s, indent + "  ", v.length);
    s << indent << "width: ";
    Printer<float>::stream(s, indent + "  ", v.width);
    s << indent << "height: ";
    Printer<float>::stream(s, indent + "  ", v.height);
    s << indent << "relative_velocity: ";
    s << std::endl;
    Printer< ::geometry_msgs::Vector3_<ContainerAllocator> >::stream(s, indent + "  ", v.relative_velocity);
    s << indent << "relative_velocity_uncertainty: ";
    s << std::endl;
    Printer< ::geometry_msgs::Vector3_<ContainerAllocator> >::stream(s, indent + "  ", v.relative_velocity_uncertainty);
    s << indent << "relative_accelerate: ";
    s << std::endl;
    Printer< ::geometry_msgs::Vector3_<ContainerAllocator> >::stream(s, indent + "  ", v.relative_accelerate);
    s << indent << "relative_accelerate_uncertainty: ";
    s << std::endl;
    Printer< ::geometry_msgs::Vector3_<ContainerAllocator> >::stream(s, indent + "  ", v.relative_accelerate_uncertainty);
    s << indent << "absolute_velocity: ";
    s << std::endl;
    Printer< ::geometry_msgs::Vector3_<ContainerAllocator> >::stream(s, indent + "  ", v.absolute_velocity);
    s << indent << "absolute_velocity_uncertainty: ";
    s << std::endl;
    Printer< ::geometry_msgs::Vector3_<ContainerAllocator> >::stream(s, indent + "  ", v.absolute_velocity_uncertainty);
    s << indent << "absolute_accelerate: ";
    s << std::endl;
    Printer< ::geometry_msgs::Vector3_<ContainerAllocator> >::stream(s, indent + "  ", v.absolute_accelerate);
    s << indent << "absolute_accelerate_uncertainty: ";
    s << std::endl;
    Printer< ::geometry_msgs::Vector3_<ContainerAllocator> >::stream(s, indent + "  ", v.absolute_accelerate_uncertainty);
    s << indent << "ObjNearestPtX: ";
    Printer<double>::stream(s, indent + "  ", v.ObjNearestPtX);
    s << indent << "ObjNearestPtY: ";
    Printer<double>::stream(s, indent + "  ", v.ObjNearestPtY);
    s << indent << "ObjNearestPtZ: ";
    Printer<double>::stream(s, indent + "  ", v.ObjNearestPtZ);
    s << indent << "chks: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.chks);
    s << indent << "cntr: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.cntr);
    s << indent << "dynamic_property: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.dynamic_property);
    s << indent << "snr: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.snr);
    s << indent << "rcs: ";
    Printer<double>::stream(s, indent + "  ", v.rcs);
    s << indent << "classification_confidence: ";
    Printer<double>::stream(s, indent + "  ", v.classification_confidence);
    s << indent << "update_bit: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.update_bit);
    s << indent << "update_flag: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.update_flag);
    s << indent << "valid_flag: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.valid_flag);
    s << indent << "speed: ";
    Printer<double>::stream(s, indent + "  ", v.speed);
    s << indent << "accelerate: ";
    Printer<double>::stream(s, indent + "  ", v.accelerate);
    s << indent << "vision_id: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.vision_id);
    s << indent << "CllsnMtgtnByBrkgPrimQly: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.CllsnMtgtnByBrkgPrimQly);
    s << indent << "CllsnMtgtnByBrkgSecQly: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.CllsnMtgtnByBrkgSecQly);
    s << indent << "EmgyLaneKeepAidPosnQly: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.EmgyLaneKeepAidPosnQly);
    s << indent << "CllsnWarnFwdQly: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.CllsnWarnFwdQly);
    s << indent << "fusion_source: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.fusion_source);
    s << indent << "time_stamp: ";
    Printer<double>::stream(s, indent + "  ", v.time_stamp);
    s << indent << "lane_offset_right: ";
    Printer<double>::stream(s, indent + "  ", v.lane_offset_right);
    s << indent << "lane_offset_right_dev: ";
    Printer<double>::stream(s, indent + "  ", v.lane_offset_right_dev);
    s << indent << "indicator_state: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.indicator_state);
  }
};

} // namespace message_operations
} // namespace ros

#endif // DATA_PARSE_MESSAGE_OBJECT_H
