// Generated by gencpp from file data_parse/ObjectFrame.msg
// DO NOT EDIT!


#ifndef DATA_PARSE_MESSAGE_OBJECTFRAME_H
#define DATA_PARSE_MESSAGE_OBJECTFRAME_H


#include <string>
#include <vector>
#include <memory>

#include <ros/types.h>
#include <ros/serialization.h>
#include <ros/builtin_message_traits.h>
#include <ros/message_operations.h>

#include <std_msgs/Header.h>
#include <data_parse/Object.h>

namespace data_parse
{
template <class ContainerAllocator>
struct ObjectFrame_
{
  typedef ObjectFrame_<ContainerAllocator> Type;

  ObjectFrame_()
    : header()
    , HostSpeed(0.0)
    , HostYawRate(0.0)
    , StsBlkd0bin(0.0)
    , StsBlkdConf(0)
    , StsChks(0)
    , StsCntr(0)
    , StsDstbc(0)
    , StsEna(0)
    , StsFaulty(0)
    , StsIfVersMajor(0)
    , StsIfVersMinor(0)
    , StsLatency(0.0)
    , StsMisAlign(0)
    , StsMissCom(0)
    , StsRdrNrDetn(0)
    , StsRdrNrObj(0)
    , StsSftyFlt(0)
    , StsTiStamp(0.0)
    , StsWhlSpdCmpFac(0)
    , TiStampStsGlbTiBas(0)
    , TiStampStsSyncToGatewy(0)
    , TiStampStsTiLeap(0)
    , TiStampStsTiOut(0)
    , sensor_type(0)
    , Blockage(0)
    , Calibration(0)
    , Fault(0)
    , objects()  {
    }
  ObjectFrame_(const ContainerAllocator& _alloc)
    : header(_alloc)
    , HostSpeed(0.0)
    , HostYawRate(0.0)
    , StsBlkd0bin(0.0)
    , StsBlkdConf(0)
    , StsChks(0)
    , StsCntr(0)
    , StsDstbc(0)
    , StsEna(0)
    , StsFaulty(0)
    , StsIfVersMajor(0)
    , StsIfVersMinor(0)
    , StsLatency(0.0)
    , StsMisAlign(0)
    , StsMissCom(0)
    , StsRdrNrDetn(0)
    , StsRdrNrObj(0)
    , StsSftyFlt(0)
    , StsTiStamp(0.0)
    , StsWhlSpdCmpFac(0)
    , TiStampStsGlbTiBas(0)
    , TiStampStsSyncToGatewy(0)
    , TiStampStsTiLeap(0)
    , TiStampStsTiOut(0)
    , sensor_type(0)
    , Blockage(0)
    , Calibration(0)
    , Fault(0)
    , objects(_alloc)  {
  (void)_alloc;
    }



   typedef  ::std_msgs::Header_<ContainerAllocator>  _header_type;
  _header_type header;

   typedef double _HostSpeed_type;
  _HostSpeed_type HostSpeed;

   typedef double _HostYawRate_type;
  _HostYawRate_type HostYawRate;

   typedef double _StsBlkd0bin_type;
  _StsBlkd0bin_type StsBlkd0bin;

   typedef uint8_t _StsBlkdConf_type;
  _StsBlkdConf_type StsBlkdConf;

   typedef uint8_t _StsChks_type;
  _StsChks_type StsChks;

   typedef uint8_t _StsCntr_type;
  _StsCntr_type StsCntr;

   typedef uint8_t _StsDstbc_type;
  _StsDstbc_type StsDstbc;

   typedef uint8_t _StsEna_type;
  _StsEna_type StsEna;

   typedef uint8_t _StsFaulty_type;
  _StsFaulty_type StsFaulty;

   typedef uint8_t _StsIfVersMajor_type;
  _StsIfVersMajor_type StsIfVersMajor;

   typedef uint8_t _StsIfVersMinor_type;
  _StsIfVersMinor_type StsIfVersMinor;

   typedef double _StsLatency_type;
  _StsLatency_type StsLatency;

   typedef uint8_t _StsMisAlign_type;
  _StsMisAlign_type StsMisAlign;

   typedef uint8_t _StsMissCom_type;
  _StsMissCom_type StsMissCom;

   typedef uint8_t _StsRdrNrDetn_type;
  _StsRdrNrDetn_type StsRdrNrDetn;

   typedef uint8_t _StsRdrNrObj_type;
  _StsRdrNrObj_type StsRdrNrObj;

   typedef uint8_t _StsSftyFlt_type;
  _StsSftyFlt_type StsSftyFlt;

   typedef double _StsTiStamp_type;
  _StsTiStamp_type StsTiStamp;

   typedef uint8_t _StsWhlSpdCmpFac_type;
  _StsWhlSpdCmpFac_type StsWhlSpdCmpFac;

   typedef uint8_t _TiStampStsGlbTiBas_type;
  _TiStampStsGlbTiBas_type TiStampStsGlbTiBas;

   typedef uint8_t _TiStampStsSyncToGatewy_type;
  _TiStampStsSyncToGatewy_type TiStampStsSyncToGatewy;

   typedef uint8_t _TiStampStsTiLeap_type;
  _TiStampStsTiLeap_type TiStampStsTiLeap;

   typedef uint8_t _TiStampStsTiOut_type;
  _TiStampStsTiOut_type TiStampStsTiOut;

   typedef uint8_t _sensor_type_type;
  _sensor_type_type sensor_type;

   typedef uint8_t _Blockage_type;
  _Blockage_type Blockage;

   typedef uint8_t _Calibration_type;
  _Calibration_type Calibration;

   typedef uint8_t _Fault_type;
  _Fault_type Fault;

   typedef std::vector< ::data_parse::Object_<ContainerAllocator> , typename std::allocator_traits<ContainerAllocator>::template rebind_alloc< ::data_parse::Object_<ContainerAllocator> >> _objects_type;
  _objects_type objects;





  typedef boost::shared_ptr< ::data_parse::ObjectFrame_<ContainerAllocator> > Ptr;
  typedef boost::shared_ptr< ::data_parse::ObjectFrame_<ContainerAllocator> const> ConstPtr;

}; // struct ObjectFrame_

typedef ::data_parse::ObjectFrame_<std::allocator<void> > ObjectFrame;

typedef boost::shared_ptr< ::data_parse::ObjectFrame > ObjectFramePtr;
typedef boost::shared_ptr< ::data_parse::ObjectFrame const> ObjectFrameConstPtr;

// constants requiring out of line definition



template<typename ContainerAllocator>
std::ostream& operator<<(std::ostream& s, const ::data_parse::ObjectFrame_<ContainerAllocator> & v)
{
ros::message_operations::Printer< ::data_parse::ObjectFrame_<ContainerAllocator> >::stream(s, "", v);
return s;
}


template<typename ContainerAllocator1, typename ContainerAllocator2>
bool operator==(const ::data_parse::ObjectFrame_<ContainerAllocator1> & lhs, const ::data_parse::ObjectFrame_<ContainerAllocator2> & rhs)
{
  return lhs.header == rhs.header &&
    lhs.HostSpeed == rhs.HostSpeed &&
    lhs.HostYawRate == rhs.HostYawRate &&
    lhs.StsBlkd0bin == rhs.StsBlkd0bin &&
    lhs.StsBlkdConf == rhs.StsBlkdConf &&
    lhs.StsChks == rhs.StsChks &&
    lhs.StsCntr == rhs.StsCntr &&
    lhs.StsDstbc == rhs.StsDstbc &&
    lhs.StsEna == rhs.StsEna &&
    lhs.StsFaulty == rhs.StsFaulty &&
    lhs.StsIfVersMajor == rhs.StsIfVersMajor &&
    lhs.StsIfVersMinor == rhs.StsIfVersMinor &&
    lhs.StsLatency == rhs.StsLatency &&
    lhs.StsMisAlign == rhs.StsMisAlign &&
    lhs.StsMissCom == rhs.StsMissCom &&
    lhs.StsRdrNrDetn == rhs.StsRdrNrDetn &&
    lhs.StsRdrNrObj == rhs.StsRdrNrObj &&
    lhs.StsSftyFlt == rhs.StsSftyFlt &&
    lhs.StsTiStamp == rhs.StsTiStamp &&
    lhs.StsWhlSpdCmpFac == rhs.StsWhlSpdCmpFac &&
    lhs.TiStampStsGlbTiBas == rhs.TiStampStsGlbTiBas &&
    lhs.TiStampStsSyncToGatewy == rhs.TiStampStsSyncToGatewy &&
    lhs.TiStampStsTiLeap == rhs.TiStampStsTiLeap &&
    lhs.TiStampStsTiOut == rhs.TiStampStsTiOut &&
    lhs.sensor_type == rhs.sensor_type &&
    lhs.Blockage == rhs.Blockage &&
    lhs.Calibration == rhs.Calibration &&
    lhs.Fault == rhs.Fault &&
    lhs.objects == rhs.objects;
}

template<typename ContainerAllocator1, typename ContainerAllocator2>
bool operator!=(const ::data_parse::ObjectFrame_<ContainerAllocator1> & lhs, const ::data_parse::ObjectFrame_<ContainerAllocator2> & rhs)
{
  return !(lhs == rhs);
}


} // namespace data_parse

namespace ros
{
namespace message_traits
{





template <class ContainerAllocator>
struct IsMessage< ::data_parse::ObjectFrame_<ContainerAllocator> >
  : TrueType
  { };

template <class ContainerAllocator>
struct IsMessage< ::data_parse::ObjectFrame_<ContainerAllocator> const>
  : TrueType
  { };

template <class ContainerAllocator>
struct IsFixedSize< ::data_parse::ObjectFrame_<ContainerAllocator> >
  : FalseType
  { };

template <class ContainerAllocator>
struct IsFixedSize< ::data_parse::ObjectFrame_<ContainerAllocator> const>
  : FalseType
  { };

template <class ContainerAllocator>
struct HasHeader< ::data_parse::ObjectFrame_<ContainerAllocator> >
  : TrueType
  { };

template <class ContainerAllocator>
struct HasHeader< ::data_parse::ObjectFrame_<ContainerAllocator> const>
  : TrueType
  { };


template<class ContainerAllocator>
struct MD5Sum< ::data_parse::ObjectFrame_<ContainerAllocator> >
{
  static const char* value()
  {
    return "c4b338d30c7b19bee12d9930eae95422";
  }

  static const char* value(const ::data_parse::ObjectFrame_<ContainerAllocator>&) { return value(); }
  static const uint64_t static_value1 = 0xc4b338d30c7b19beULL;
  static const uint64_t static_value2 = 0xe12d9930eae95422ULL;
};

template<class ContainerAllocator>
struct DataType< ::data_parse::ObjectFrame_<ContainerAllocator> >
{
  static const char* value()
  {
    return "data_parse/ObjectFrame";
  }

  static const char* value(const ::data_parse::ObjectFrame_<ContainerAllocator>&) { return value(); }
};

template<class ContainerAllocator>
struct Definition< ::data_parse::ObjectFrame_<ContainerAllocator> >
{
  static const char* value()
  {
    return "std_msgs/Header header\n"
"\n"
"float64 HostSpeed\n"
"float64 HostYawRate\n"
"float64 StsBlkd0bin\n"
"uint8 StsBlkdConf\n"
"uint8 StsChks\n"
"uint8 StsCntr\n"
"uint8 StsDstbc\n"
"uint8 StsEna\n"
"uint8 StsFaulty\n"
"uint8 StsIfVersMajor\n"
"uint8 StsIfVersMinor\n"
"float64 StsLatency\n"
"uint8 StsMisAlign\n"
"uint8 StsMissCom\n"
"uint8 StsRdrNrDetn\n"
"uint8 StsRdrNrObj\n"
"uint8 StsSftyFlt\n"
"float64 StsTiStamp\n"
"uint8 StsWhlSpdCmpFac\n"
"uint8 TiStampStsGlbTiBas\n"
"uint8 TiStampStsSyncToGatewy\n"
"uint8 TiStampStsTiLeap\n"
"uint8 TiStampStsTiOut\n"
"\n"
"uint8 sensor_type\n"
"\n"
"uint8 Blockage\n"
"uint8 Calibration\n"
"uint8 Fault\n"
"\n"
"Object[] objects\n"
"================================================================================\n"
"MSG: std_msgs/Header\n"
"# Standard metadata for higher-level stamped data types.\n"
"# This is generally used to communicate timestamped data \n"
"# in a particular coordinate frame.\n"
"# \n"
"# sequence ID: consecutively increasing ID \n"
"uint32 seq\n"
"#Two-integer timestamp that is expressed as:\n"
"# * stamp.sec: seconds (stamp_secs) since epoch (in Python the variable is called 'secs')\n"
"# * stamp.nsec: nanoseconds since stamp_secs (in Python the variable is called 'nsecs')\n"
"# time-handling sugar is provided by the client library\n"
"time stamp\n"
"#Frame this data is associated with\n"
"string frame_id\n"
"\n"
"================================================================================\n"
"MSG: data_parse/Object\n"
"# BO_ 1345 Objects_Header: 3 Vector__XXX\n"
"#  SG_ Sync_Frame_Index : 0|8@1+ (1,0) [0|255] \"counter\" Vector__XXX\n"
"#  SG_ Num_Of_Video_Objs : 8|4@1+ (1,0) [0|12] \"counter\" Vector__XXX\n"
"#  SG_ VD_CIPV_ID : 12|7@1+ (1,0) [0|127] \"counter\" Vector__XXX\n"
"#  SG_ VD_CIPV_Lost : 19|2@1+ (1,0) [0|2] \"ENUM\" Vector__XXX\n"
"#  SG_ OBJ_VD_Allow_Acc : 21|2@1+ (1,0) [0|2] \"ENUM\" Vector__XXX\n"
"#  SG_ Reserved : 23|1@1+ (1,0) [0|0] \"NA\" Vector__XXX\n"
"\n"
"# BO_ 1280 Objects_Signals_A1: 7 Vector__XXX\n"
"#  SG_ Obj_ID_1 : 0|7@1+ (1,0) [0|127] \"counter\" Vector__XXX\n"
"#  SG_ Object_Class_1 : 7|3@1+ (1,0) [0|7] \"ENUM\" Vector__XXX\n"
"#  SG_ OBJ_Width_1 : 10|7@1+ (0.05,0) [0|6.35] \"m\" Vector__XXX\n"
"#  SG_ OBJ_Length_1 : 17|9@1+ (0.05,0) [0|25.5] \"m\" Vector__XXX\n"
"#  SG_ Relative_Long_Velocity_1 : 26|13@1+ (0.05,-120) [-120|130] \"m/s\" Vector__XXX\n"
"#  SG_ OBJ_Lane_Assignment_1 : 39|3@1+ (1,0) [0|5] \"ENUM\" Vector__XXX\n"
"#  SG_ Relative_Lat_Velocity_1 : 42|11@1+ (0.05,-50) [-50|50] \"m/s\" Vector__XXX\n"
"#  SG_ Reserved : 53|3@1+ (1,0) [0|0] \"NA\" Vector__XXX\n"
"\n"
"\n"
"# BO_ 1281 Objects_Signals_B1: 5 Vector__XXX\n"
"#  SG_ Absolute_Long_Acc_1 : 0|9@1+ (0.05,-12.8) [-12.8|12.75] \"m/s2\" Vector__XXX\n"
"#  SG_ Long_Distance_1 : 9|13@1+ (0.05,0) [0|350] \"m\" Vector__XXX\n"
"#  SG_ Lateral_Distance_1 : 22|12@1+ (0.05,-102.4) [-102.4|102.3] \"m\" Vector__XXX\n"
"#  SG_ Reserved : 34|6@1+ (1,0) [0|0] \"NA\" Vector__XXX\n"
"\n"
"\n"
"# BO_ 1282 Objects_Signals_C1: 7 Vector__XXX\n"
"#  SG_ Absolute_Speed_1 : 0|12@1+ (0.05,-100) [-100|100] \"m/s\" Vector__XXX\n"
"#  SG_ OBJ_Motion_Status_1 : 12|3@1+ (1,0) [0|4] \"ENUM \" Vector__XXX\n"
"#  SG_ OBJ_Motion_Category_1 : 15|4@1+ (1,0) [0|12] \"ENUM \" Vector__XXX\n"
"#  SG_ Brake_Light_1 : 19|1@1+ (1,0) [0|1] \"bool\" Vector__XXX\n"
"#  SG_ Turn_Indicator_Right_1 : 20|1@1+ (1,0) [0|1] \"bool\" Vector__XXX\n"
"#  SG_ Turn_Indicator_Left_1 : 21|1@1+ (1,0) [0|1] \"bool\" Vector__XXX\n"
"#  SG_ Light_indicator_validity_1 : 22|1@1+ (1,0) [0|1] \"bool\" Vector__XXX\n"
"#  SG_ OBJ_Angle_Mid_1 : 23|14@1+ (0.0002,-1.571) [-1.571|1.571] \"rad\" Vector__XXX\n"
"#  SG_ OBJ_Angle_Rate_1 : 37|12@1+ (0.002,-2.234) [-2.234|2.2318] \"rad/s\" Vector__XXX\n"
"#  SG_ Reserved : 49|7@1+ (1,0) [0|0] \"NA\" Vector__XXX\n"
"\n"
"uint8 UNCLASSIFIED=0\n"
"uint8 UNKNOWN_SMALL=1\n"
"uint8 UNKNOWN_BIG=2\n"
"uint8 PEDESTRIAN=3\n"
"uint8 BIKE=4\n"
"uint8 CAR=5\n"
"uint8 TRUCK=6\n"
"\n"
"#### ID of this object from tracking. \n"
"#* Obj_ID_1\n"
"uint16 id\n"
"\n"
"#### Number of scans this object has been tracked for.\n"
"int16 life_cycles\n"
"\n"
"#### Most likely class of this object(see top)\n"
"#* Object_Class_1\n"
"uint8 classification\n"
"\n"
"#### The higher this value is the more reliable is the assigned object class\n"
"float64 obstacle_probability\n"
"\n"
"#### The higher this value is the more reliable is the assigned object class\n"
"float64 probability_existence\n"
"\n"
"#### x,y,z in m\n"
"#* Long_Distance_1  Lateral_Distance_1\n"
"geometry_msgs/Vector3 center\n"
"\n"
"#### position untertainty\n"
"geometry_msgs/Vector3 center_uncertainty\n"
"\n"
"#### yaw angle \n"
"#* OBJ_Angle_Rate_1  \n"
"#* OBJ_Angle_Mid_1 \n"
"float64 heading_angle \n"
"\n"
"#### yaw angle uncertainty\n"
"float64 heading_angle_uncertainty\n"
"\n"
"#### Size of the object box in the object, X - length in m\n"
"#* OBJ_Length_1\n"
"float32 length\n"
"\n"
"#### Size of the object box in the object, Y - length in m\n"
"#* OBJ_Width_1\n"
"float32 width\n"
"\n"
"#### Size of the object box in the object, Z - length in m\n"
"float32 height\n"
"\n"
"#### relative_velocity in m/s\n"
"#* Relative_Lat_Velocity_1  Relative_Long_Velocity_1\n"
"geometry_msgs/Vector3 relative_velocity\n"
"\n"
"#### relative_velocity untertainty\n"
"geometry_msgs/Vector3 relative_velocity_uncertainty\n"
"\n"
"#### relative_accelerate in m/s\n"
"geometry_msgs/Vector3 relative_accelerate\n"
"\n"
"#### relative_accelerate untertainty\n"
"geometry_msgs/Vector3 relative_accelerate_uncertainty\n"
"\n"
"#### absolute_velocity in m/s\n"
"#* Absolute_Speed_1\n"
"geometry_msgs/Vector3 absolute_velocity\n"
"\n"
"#### absolute_velocity untertainty\n"
"geometry_msgs/Vector3 absolute_velocity_uncertainty\n"
"\n"
"#### absolute_accelerate in m/s\n"
"#* Absolute_Long_Acc_1\n"
"geometry_msgs/Vector3 absolute_accelerate\n"
"\n"
"#### absolute_accelerate untertainty\n"
"geometry_msgs/Vector3 absolute_accelerate_uncertainty\n"
"\n"
"float64 ObjNearestPtX\n"
"float64 ObjNearestPtY\n"
"float64 ObjNearestPtZ\n"
"\n"
"uint8 chks\n"
"uint8 cntr\n"
"uint8 dynamic_property\n"
"uint8 snr\n"
"float64 rcs\n"
"float64 classification_confidence\n"
"uint8 update_bit\n"
"uint8 update_flag\n"
"uint8 valid_flag\n"
"float64 speed\n"
"float64 accelerate\n"
"uint8 vision_id\n"
"uint8 CllsnMtgtnByBrkgPrimQly\n"
"uint8 CllsnMtgtnByBrkgSecQly\n"
"uint8 EmgyLaneKeepAidPosnQly\n"
"uint8 CllsnWarnFwdQly\n"
"\n"
"uint8 fusion_source\n"
"\n"
"float64 time_stamp\n"
"\n"
"#float64 isp_time_stamp\n"
"\n"
"# enum\n"
"#uint8 Cms_confidence\n"
"#uint8 CmsConfidence1_Invalid = 0\n"
"#uint8 CmsConfidence1_Valid = 1\n"
"#uint8 CmsConfidence1_Reserved = 2\n"
"#uint8 CmsConfidence1_Reserved1 = 3\n"
"\n"
"\n"
"float64 lane_offset_right\n"
"float64 lane_offset_right_dev\n"
"\n"
"\n"
"# ENUM for classification\n"
"uint8 CLASS_UNKNOWN              = 0\n"
"uint8 CLASS_CAR                  = 1\n"
"uint8 CLASS_TRUCK                = 2\n"
"uint8 CLASS_MOTORCYCLE           = 3\n"
"uint8 CLASS_CYCLIST              = 4   # bicyle, E-Scooter, tricyclist\n"
"uint8 CLASS_PEDESTRIAN           = 5\n"
"uint8 CLASS_ROAD_BARRIER         = 6   # traffic cone, parking gate, road barrier\n"
"uint8 CLASS_MAX_NUM              = 7\n"
"\n"
"\n"
"# ENUM for flash light status of the object\n"
"uint8 INDICATOR_UNDEFINED        = 0   # Flash light status is not defined for non-vehicle objects\n"
"uint8 INDICATOR_OFF              = 1   # Flash light is currenhtly not active\n"
"uint8 INDICATOR_RIGHT            = 2   # Right flash light is on and/or blinking\n"
"uint8 INDICATOR_LEFT             = 3   # Left flash light is on and/or blinking\n"
"uint8 INDICATOR_BOTH             = 4   # Flash lights from both side are on and/or blinking\n"
"\n"
"# Flash light status of the object, if applicable (see enum for details)\n"
"#* Turn_Indicator_Left_1 Turn_Indicator_Right_1\n"
"uint8 indicator_state                  # [INDICATOR_*]\n"
"\n"
"================================================================================\n"
"MSG: geometry_msgs/Vector3\n"
"# This represents a vector in free space. \n"
"# It is only meant to represent a direction. Therefore, it does not\n"
"# make sense to apply a translation to it (e.g., when applying a \n"
"# generic rigid transformation to a Vector3, tf2 will only apply the\n"
"# rotation). If you want your data to be translatable too, use the\n"
"# geometry_msgs/Point message instead.\n"
"\n"
"float64 x\n"
"float64 y\n"
"float64 z\n"
;
  }

  static const char* value(const ::data_parse::ObjectFrame_<ContainerAllocator>&) { return value(); }
};

} // namespace message_traits
} // namespace ros

namespace ros
{
namespace serialization
{

  template<class ContainerAllocator> struct Serializer< ::data_parse::ObjectFrame_<ContainerAllocator> >
  {
    template<typename Stream, typename T> inline static void allInOne(Stream& stream, T m)
    {
      stream.next(m.header);
      stream.next(m.HostSpeed);
      stream.next(m.HostYawRate);
      stream.next(m.StsBlkd0bin);
      stream.next(m.StsBlkdConf);
      stream.next(m.StsChks);
      stream.next(m.StsCntr);
      stream.next(m.StsDstbc);
      stream.next(m.StsEna);
      stream.next(m.StsFaulty);
      stream.next(m.StsIfVersMajor);
      stream.next(m.StsIfVersMinor);
      stream.next(m.StsLatency);
      stream.next(m.StsMisAlign);
      stream.next(m.StsMissCom);
      stream.next(m.StsRdrNrDetn);
      stream.next(m.StsRdrNrObj);
      stream.next(m.StsSftyFlt);
      stream.next(m.StsTiStamp);
      stream.next(m.StsWhlSpdCmpFac);
      stream.next(m.TiStampStsGlbTiBas);
      stream.next(m.TiStampStsSyncToGatewy);
      stream.next(m.TiStampStsTiLeap);
      stream.next(m.TiStampStsTiOut);
      stream.next(m.sensor_type);
      stream.next(m.Blockage);
      stream.next(m.Calibration);
      stream.next(m.Fault);
      stream.next(m.objects);
    }

    ROS_DECLARE_ALLINONE_SERIALIZER
  }; // struct ObjectFrame_

} // namespace serialization
} // namespace ros

namespace ros
{
namespace message_operations
{

template<class ContainerAllocator>
struct Printer< ::data_parse::ObjectFrame_<ContainerAllocator> >
{
  template<typename Stream> static void stream(Stream& s, const std::string& indent, const ::data_parse::ObjectFrame_<ContainerAllocator>& v)
  {
    s << indent << "header: ";
    s << std::endl;
    Printer< ::std_msgs::Header_<ContainerAllocator> >::stream(s, indent + "  ", v.header);
    s << indent << "HostSpeed: ";
    Printer<double>::stream(s, indent + "  ", v.HostSpeed);
    s << indent << "HostYawRate: ";
    Printer<double>::stream(s, indent + "  ", v.HostYawRate);
    s << indent << "StsBlkd0bin: ";
    Printer<double>::stream(s, indent + "  ", v.StsBlkd0bin);
    s << indent << "StsBlkdConf: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.StsBlkdConf);
    s << indent << "StsChks: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.StsChks);
    s << indent << "StsCntr: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.StsCntr);
    s << indent << "StsDstbc: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.StsDstbc);
    s << indent << "StsEna: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.StsEna);
    s << indent << "StsFaulty: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.StsFaulty);
    s << indent << "StsIfVersMajor: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.StsIfVersMajor);
    s << indent << "StsIfVersMinor: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.StsIfVersMinor);
    s << indent << "StsLatency: ";
    Printer<double>::stream(s, indent + "  ", v.StsLatency);
    s << indent << "StsMisAlign: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.StsMisAlign);
    s << indent << "StsMissCom: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.StsMissCom);
    s << indent << "StsRdrNrDetn: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.StsRdrNrDetn);
    s << indent << "StsRdrNrObj: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.StsRdrNrObj);
    s << indent << "StsSftyFlt: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.StsSftyFlt);
    s << indent << "StsTiStamp: ";
    Printer<double>::stream(s, indent + "  ", v.StsTiStamp);
    s << indent << "StsWhlSpdCmpFac: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.StsWhlSpdCmpFac);
    s << indent << "TiStampStsGlbTiBas: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.TiStampStsGlbTiBas);
    s << indent << "TiStampStsSyncToGatewy: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.TiStampStsSyncToGatewy);
    s << indent << "TiStampStsTiLeap: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.TiStampStsTiLeap);
    s << indent << "TiStampStsTiOut: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.TiStampStsTiOut);
    s << indent << "sensor_type: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.sensor_type);
    s << indent << "Blockage: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.Blockage);
    s << indent << "Calibration: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.Calibration);
    s << indent << "Fault: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.Fault);
    s << indent << "objects[]" << std::endl;
    for (size_t i = 0; i < v.objects.size(); ++i)
    {
      s << indent << "  objects[" << i << "]: ";
      s << std::endl;
      s << indent;
      Printer< ::data_parse::Object_<ContainerAllocator> >::stream(s, indent + "    ", v.objects[i]);
    }
  }
};

} // namespace message_operations
} // namespace ros

#endif // DATA_PARSE_MESSAGE_OBJECTFRAME_H
